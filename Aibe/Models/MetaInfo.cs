using Aibe.Models.Core;
using Aibe.Models.DB;
using Aibe.Helpers;
using Extension.Database.SqlServer;
using Extension.Models;
using Extension.String;
using System;
using System.Collections.Generic;
using System.Data;
using System.Linq;
using System.Text;
using System.Data.SqlClient;

namespace Aibe.Models {
  public class MetaInfo {
    public string TableName { get; private set; }
    public string TableDisplayName { get; private set; }
    private string _tableSource;
    public string TableSource { get { return string.IsNullOrWhiteSpace(_tableSource) ? TableName : _tableSource; } }
    public List<PrefilledColumnInfo> PrefilledColumns { get; private set; } = new List<PrefilledColumnInfo>();
    private const short defaultItemsPerPage = 20;
    public short ItemsPerPage { get; private set; } = defaultItemsPerPage; //give default value 20
    public List<OrderByInfo> OrderBys { get; private set; } = new List<OrderByInfo>();
    public List<ActionInfo> Actions { get; private set; } = new List<ActionInfo>();
    public List<string> DefaultActions { get; private set; } = new List<string>();
    public List<ActionInfo> TableActions { get; private set; } = new List<ActionInfo>();
    public List<string> DefaultTableActions { get; private set; } = new List<string>();
    public List<TextFieldColumnInfo> TextFieldColumns { get; private set; } = new List<TextFieldColumnInfo>();
    public List<PictureColumnInfo> PictureColumns { get; private set; } = new List<PictureColumnInfo>();
    public List<string> IndexShownPictureColumns { get; private set; } = new List<string>();
    public List<string> RequiredColumns { get; private set; } = new List<string>();
    public List<NumberLimitColumnInfo> NumberLimitColumns { get; private set; } = new List<NumberLimitColumnInfo>();
    public List<RegexCheckedColumnInfo> RegexCheckedColumns { get; private set; } = new List<RegexCheckedColumnInfo>();
    public List<RegexCheckedColumnExampleInfo> RegexCheckedColumnExamples { get; private set; } = new List<RegexCheckedColumnExampleInfo>();
    public List<UserRelatedFilterInfo> UserRelatedFilters { get; private set; } = new List<UserRelatedFilterInfo>();
    public bool FilterIsDisabled { get; private set; }
    public List<InclusionInfo> ForcedFilterColumns { get; private set; } = new List<InclusionInfo>();
    public List<ExclusionInfo> ColumnExclusions { get; private set; } = new List<ExclusionInfo>();
    public List<ExclusionInfo> FilterExclusions { get; private set; } = new List<ExclusionInfo>();
    public List<ExclusionInfo> DetailsExclusions { get; private set; } = new List<ExclusionInfo>();
    public List<ExclusionInfo> CreateEditExclusions { get; private set; } = new List<ExclusionInfo>();
    public List<ExclusionInfo> CsvExclusions { get; private set; } = new List<ExclusionInfo>();
    public List<string> AccessExclusions { get; private set; } = new List<string>();
    public List<ColoringInfo> Colorings { get; private set; } = new List<ColoringInfo>();
    public List<DropDownInfo> FilterDropDowns { get; private set; } = new List<DropDownInfo>();
    public List<DropDownInfo> CreateEditDropDowns { get; private set; } = new List<DropDownInfo>();
    public List<AffixColumnInfo> PrefixesOfColumns { get; private set; } = new List<AffixColumnInfo>();
    public List<AffixColumnInfo> PostfixesOfColumns { get; private set; } = new List<AffixColumnInfo>();
    public List<ListColumnInfo> ListColumns { get; private set; } = new List<ListColumnInfo>();
    public List<TimeStampColumnInfo> TimeStampColumns { get; private set; } = new List<TimeStampColumnInfo>();
    public HistoryInfo HistoryTable { get; private set; }
    public List<HistoryTriggerInfo> HistoryTriggers { get; private set; } = new List<HistoryTriggerInfo>();
    public List<AutoGeneratedColumnInfo> AutoGeneratedColumns { get; private set; } = new List<AutoGeneratedColumnInfo>();
    public List<string> ColumnSequence { get; private set; } = new List<string>();
    public Dictionary<string, string> ColumnAliases { get; private set; } = new Dictionary<string, string>();
    public List<string> EditShowOnlyColumns { get; private set; } = new List<string>();
    public List<ScriptConstructorColumnInfo> ScriptConstructorColumns { get; private set; } = new List<ScriptConstructorColumnInfo>();
    public List<ScriptColumnInfo> ScriptColumns { get; private set; } = new List<ScriptColumnInfo>();
    public List<CustomDateTimeFormatInfo> CustomDateTimeFormatColumns { get; private set; } = new List<CustomDateTimeFormatInfo>();
    public List<EmailMakerTriggerInfo> EmailMakerTriggers { get; private set; } = new List<EmailMakerTriggerInfo>();
    public List<EmailMakerInfo> EmailMakers { get; private set; } = new List<EmailMakerInfo>();
    public List<AttachmentInfo> NonPictureAttachments { get; private set; } = new List<AttachmentInfo>();
    public List<string> DownloadColumns { get; private set; } = new List<string>();
    public List<ActionTriggerInfo> PreActionTriggers { get; private set; } = new List<ActionTriggerInfo>();
    public List<ActionProcedureInfo> PreActionProcedures { get; private set; } = new List<ActionProcedureInfo>();
    public List<ActionTriggerInfo> PostActionTriggers { get; private set; } = new List<ActionTriggerInfo>();
    public List<ActionProcedureInfo> PostActionProcedures { get; private set; } = new List<ActionProcedureInfo>();
    public string TableType { get; private set; } = DH.NormalTableType;
    public AggregationStatementInfo AggregationStatement { get; private set; }
    public List<ForeignInfoColumnInfo> ForeignInfoColumns { get; private set; } = new List<ForeignInfoColumnInfo>();

    //Extra properties
    public bool IsValid { get; private set; }
    public List<ActionProcedureFullInfo> PreActionProcedureFulls { get; private set; } = new List<ActionProcedureFullInfo>();
    public List<ActionProcedureFullInfo> PostActionProcedureFulls { get; private set; } = new List<ActionProcedureFullInfo>();
    public List<EmailMakerFullInfo> EmailMakerFulls { get; private set; } = new List<EmailMakerFullInfo>();
    public List<DataColumn> RawDataColumns { get; set; } //This is just to get DataColumn, not DataRow, so that the info about this column in the database is known
    public List<string> RawDataColumnNames { get; set; } 
    public List<DataColumn> ArrangedDataColumns { get; private set; } //This is just to get DataColumn, not DataRow, so that the info about this column in the database is known
    private List<string> dateTimeColumns { get; set; } //this is taken from the database

    //Extra get-only properties
    public bool IsGroupTable { get {
        return TableType != null && TableType.EqualsIgnoreCase(DH.GroupTableType) &&
          AggregationStatement != null && AggregationStatement.IsValid;
      } }
    public List<string> GroupByColumns { get { return IsGroupTable ? AggregationStatement.GroupByColumns.Select(x => x.Key).ToList() : new List<string>(); } }
    public List<GroupByColumnInfo> GroupByColumnInfos { get { return IsGroupTable ? AggregationStatement.GroupByColumns.Select(x => x.Value).ToList() : new List<GroupByColumnInfo>(); } }
    public bool HasValidHistoryTable { get { return HistoryTable != null && HistoryTriggers != null && HistoryTriggers.Any(); } }
    public bool HasAnyAction { get { return Actions != null && Actions.Any(); } }
    public bool HasDefaultAction { get { return Actions != null && Actions.Any(x => DH.DefaultRowActions.Any(
      y => y.EqualsIgnoreCaseTrim(x.Name))); } }
    public bool HasDefaultGroupAction { get { return Actions != null && Actions.Any(x => DH.DefaultGroupByRowActions.Any(
      y => y.EqualsIgnoreCaseTrim(x.Name))); } }
    public bool HasAnyCreateAction { get { return Actions != null && Actions.Any(x => DH.DefaultAllCreateRowActions.Any(
      y => y.EqualsIgnoreCaseTrim(x.Name))); } }
    public bool HasCreateAction { get { return Actions != null && Actions.Any(x => x.Name.EqualsIgnoreCaseTrim(DH.CreateActionName)); } }
    public bool HasCreateGroupAction { get { return Actions != null && Actions.Any(x => x.Name.EqualsIgnoreCaseTrim(DH.CreateGroupActionName)); } }
    public bool HasAnyNonCreateAction { get { return Actions != null && Actions.Any(x => !x.Name.EqualsIgnoreCaseTrim(DH.CreateActionName)
      && !x.Name.EqualsIgnoreCaseTrim(DH.CreateGroupActionName)); } }
    public bool HasNonDefaultGroupNonCreateAction { get { return Actions != null 
      && Actions.Any(x => !x.Name.EqualsIgnoreCaseTrim(DH.CreateActionName) //cannot be create actions
      && !x.Name.EqualsIgnoreCaseTrim(DH.CreateGroupActionName)
      && !DH.DefaultGroupByNonCreateRowActions.Any(y => y.EqualsIgnoreCaseTrim(x.Name))); } } //cannot be default group actions too
    public bool HasDefaultNonCreateAction { get { return Actions != null && Actions.Any(x => DH.DefaultNonCreateRowActions.Any(
      y => y.EqualsIgnoreCaseTrim(x.Name))); } }
    public bool HasDefaultGroupNonCreateAction { get { return Actions != null && Actions.Any(x => DH.DefaultGroupByNonCreateRowActions.Any(
      y => y.EqualsIgnoreCaseTrim(x.Name))); } }
    public bool HasIndexNonCreateAction { get { return (!IsGroupTable && HasNonDefaultGroupNonCreateAction) 
          || (IsGroupTable && HasDefaultGroupNonCreateAction); } }
    public bool HasGroupDetailsNonCreateAction { get { return HasNonDefaultGroupNonCreateAction; } }
    public List<ActionInfo> AllNonCreateActions { get { return Actions?.Where(x => !x.Name.EqualsIgnoreCaseTrim(DH.CreateActionName)
      && !x.Name.EqualsIgnoreCaseTrim(DH.CreateGroupActionName)).ToList(); } }
    public List<ActionInfo> DefaultNonCreateActions { get { return Actions?.Where(x => DH.DefaultNonCreateRowActions.Any(
      y => y.EqualsIgnoreCaseTrim(x.Name))).ToList(); } }
    public List<ActionInfo> DefaultGroupNonCreateActions { get { return Actions?.Where(x => DH.DefaultGroupByNonCreateRowActions.Any(
      y => y.EqualsIgnoreCaseTrim(x.Name))).ToList(); } }
    public List<ActionInfo> NonDefaultGroupNonCreateActions { get { return Actions?.Where(x =>
      !x.Name.EqualsIgnoreCaseTrim(DH.CreateActionName) //cannot be create actions
      && !x.Name.EqualsIgnoreCaseTrim(DH.CreateGroupActionName)
      && !DH.DefaultGroupByNonCreateRowActions.Any(y => y.EqualsIgnoreCaseTrim(x.Name))).ToList(); }
    } //cannot be default group actions too
    public List<ActionInfo> GroupDetailsNonCreateActions { get { return NonDefaultGroupNonCreateActions; } }
    public List<ActionInfo> IndexNonCreateActions { get { return IsGroupTable ?
          DefaultGroupNonCreateActions : NonDefaultGroupNonCreateActions; } }
    public bool HasTableAction { get { return TableActions != null && TableActions.Any(); } }

    public MetaInfo (IMetaItem metaItem) {
      AssignParameters(metaItem);
    }

    //Assign parameters
    public void AssignParameters(IMetaItem metaItem) {
      if (metaItem == null || string.IsNullOrWhiteSpace(metaItem.TableName)) //null meta makes an invalid item
        return;

      TableName = metaItem.TableName;
      _tableSource = metaItem.TableSource; //take from IMetaItem.TableSource here...

      try { //do this as early as not to waste time... if we cannot proceed further
        RawDataColumns = SQLServerHandler.GetColumns(DH.DataDBConnectionString, TableSource); //using TableSource instead of TableName here
        RawDataColumnNames = RawDataColumns.Select(x => x.ColumnName).ToList(); //needed for some things like CSV builder.
      } catch {
        //Invalid, do not use!
        return;
      }

      dateTimeColumns = RawDataColumns.Where(x => x.DataType.ToString()
        .Substring(DH.SharedPrefixDataType.Length).EqualsIgnoreCase(DH.DateTimeDataType))
        .Select(x => x.ColumnName)
        .ToList();
      
      TableDisplayName = string.IsNullOrWhiteSpace(metaItem.DisplayName) ? metaItem.TableName.ToCamelBrokenString() : //still uses TableName instead of TableSource here
          metaItem.DisplayName;
      if (!string.IsNullOrWhiteSpace(metaItem.PrefilledColumns))
        PrefilledColumns = metaItem.PrefilledColumns.ParseComponents()
          .Select(x => new PrefilledColumnInfo(x)).Where(x => x.IsValid).ToList();
      else if (PrefilledColumns != null && PrefilledColumns.Count > 0)
        PrefilledColumns.Clear();
      ItemsPerPage = metaItem.ItemsPerPage == null ? defaultItemsPerPage : metaItem.ItemsPerPage.Value;
      if (!string.IsNullOrWhiteSpace(metaItem.OrderBy)) {
        if (metaItem.OrderBy.Trim().StartsWith(DH.SQLScriptDirectivePrefix)) { //special order by using SQL script directive
          OrderByInfo obInfo = new OrderByInfo(metaItem.OrderBy, true);
          OrderBys = obInfo.IsValid ? new List<OrderByInfo>() { obInfo } : new List<OrderByInfo>();
        } else //normal order-bys
          OrderBys = metaItem.OrderBy.GetTrimmedNonEmptyParts(';')
            .Select(x => new OrderByInfo(x, false)).Where(x => x.IsValid).ToList();
      } else if (OrderBys != null && OrderBys.Count > 0)
        OrderBys.Clear();
      if (!string.IsNullOrWhiteSpace(metaItem.ActionList))
        Actions = metaItem.ActionList.GetTrimmedNonEmptyParts(';')
          .Select(x => new ActionInfo(x)).Where(x => x.IsValid).ToList();
      else if (Actions != null && Actions.Count > 0)
        Actions.Clear();
      if (!string.IsNullOrWhiteSpace(metaItem.DefaultActionList))
        DefaultActions = metaItem.DefaultActionList.GetTrimmedNonEmptyParts(';');
      else if (DefaultActions != null && DefaultActions.Count > 0)
        DefaultActions.Clear();
      if (!string.IsNullOrWhiteSpace(metaItem.TableActionList))
        TableActions = metaItem.TableActionList.GetTrimmedNonEmptyParts(';')
          .Select(x => new ActionInfo(x)).Where(x => x.IsValid).ToList();
      else if (TableActions != null && TableActions.Count > 0)
        TableActions.Clear();
      if (!string.IsNullOrWhiteSpace(metaItem.DefaultTableActionList))
        DefaultTableActions = metaItem.DefaultTableActionList.GetTrimmedNonEmptyParts(';');
      else if (DefaultTableActions != null && DefaultTableActions.Count > 0)
        DefaultTableActions.Clear();
      if (!string.IsNullOrWhiteSpace(metaItem.TextFieldColumns))
        TextFieldColumns = metaItem.TextFieldColumns.GetTrimmedNonEmptyParts(';')
          .Select(x => new TextFieldColumnInfo(x)).Where(x => x.IsValid).ToList();
      else if (TextFieldColumns != null && TextFieldColumns.Count > 0)
        TextFieldColumns.Clear();
      if (!string.IsNullOrWhiteSpace(metaItem.PictureColumns))
        PictureColumns = metaItem.PictureColumns.GetTrimmedNonEmptyParts(';')
          .Select(x => new PictureColumnInfo(x)).Where(x => x.IsValid).ToList();
      else if (PictureColumns != null && PictureColumns.Count > 0)
        PictureColumns.Clear();
      if (!string.IsNullOrWhiteSpace(metaItem.IndexShownPictureColumns))
        IndexShownPictureColumns = metaItem.IndexShownPictureColumns.GetTrimmedNonEmptyParts(';');
      else if (IndexShownPictureColumns != null && IndexShownPictureColumns.Count > 0)
        IndexShownPictureColumns.Clear();
      if (!string.IsNullOrWhiteSpace(metaItem.RequiredColumns))
        RequiredColumns = metaItem.RequiredColumns.GetTrimmedNonEmptyParts(';');
      else if (RequiredColumns != null && RequiredColumns.Count > 0)
        RequiredColumns.Clear();
      if (!string.IsNullOrWhiteSpace(metaItem.NumberLimitColumns))
        NumberLimitColumns = metaItem.NumberLimitColumns.GetTrimmedNonEmptyParts(';')
          .Select(x => new NumberLimitColumnInfo(x)).Where(x => x.IsValid).ToList();
      else if (NumberLimitColumns != null && NumberLimitColumns.Count > 0)
        NumberLimitColumns.Clear();
      if (!string.IsNullOrWhiteSpace(metaItem.RegexCheckedColumns))
        RegexCheckedColumns = metaItem.RegexCheckedColumns.GetXMLTaggedInnerStrings(DH.RegexCheckedColumnTag)
          .Select(x => new RegexCheckedColumnInfo(x)).Where(x => x.IsValid).ToList();
      else if (RegexCheckedColumns != null && RegexCheckedColumns.Count > 0)
        RegexCheckedColumns.Clear();
      if (!string.IsNullOrWhiteSpace(metaItem.RegexCheckedColumnExamples))
        RegexCheckedColumnExamples = metaItem.RegexCheckedColumnExamples.GetXMLTaggedInnerStrings(DH.RegexCheckedColumnExampleTag)
          .Select(x => new RegexCheckedColumnExampleInfo(x)).Where(x => x.IsValid).ToList();
      else if (RegexCheckedColumnExamples != null && RegexCheckedColumnExamples.Count > 0)
        RegexCheckedColumnExamples.Clear();
      if (!string.IsNullOrWhiteSpace(metaItem.UserRelatedFilters))
        UserRelatedFilters = metaItem.UserRelatedFilters.GetTrimmedNonEmptyParts(';')
          .Select(x => new UserRelatedFilterInfo(x)).Where(x => x.IsValid).ToList(); //exclude non successful parsing result
      else if (UserRelatedFilters != null && UserRelatedFilters.Count > 0)
        UserRelatedFilters.Clear();
      FilterIsDisabled = metaItem.DisableFilter != null && metaItem.DisableFilter.Value;
      if (!string.IsNullOrWhiteSpace(metaItem.ForcedFilterColumns))
        ForcedFilterColumns = metaItem.ForcedFilterColumns.GetTrimmedNonEmptyParts(';')
          .Select(x => new InclusionInfo(x)).Where(x => x.IsValid).ToList();
      else if (ForcedFilterColumns != null && ForcedFilterColumns.Count > 0)
        ForcedFilterColumns.Clear();
      if (!string.IsNullOrWhiteSpace(metaItem.ColumnExclusionList))
        ColumnExclusions = metaItem.ColumnExclusionList.GetTrimmedNonEmptyParts(';')
          .Select(x => new ExclusionInfo(x)).Where(x => x.IsValid).ToList();
      else if (ColumnExclusions != null && ColumnExclusions.Count > 0)
        ColumnExclusions.Clear();
      if (!string.IsNullOrWhiteSpace(metaItem.FilterExclusionList))
        FilterExclusions = metaItem.FilterExclusionList.GetTrimmedNonEmptyParts(';')
          .Select(x => new ExclusionInfo(x)).Where(x => x.IsValid).ToList();
      else if (FilterExclusions != null && FilterExclusions.Count > 0)
        FilterExclusions.Clear();
      if (!string.IsNullOrWhiteSpace(metaItem.DetailsExclusionList))
        DetailsExclusions = metaItem.DetailsExclusionList.GetTrimmedNonEmptyParts(';')
          .Select(x => new ExclusionInfo(x)).Where(x => x.IsValid).ToList();
      else if (DetailsExclusions != null && DetailsExclusions.Count > 0)
        DetailsExclusions.Clear();
      if (!string.IsNullOrWhiteSpace(metaItem.CreateEditExclusionList))
        CreateEditExclusions = metaItem.CreateEditExclusionList.GetTrimmedNonEmptyParts(';')
          .Select(x => new ExclusionInfo(x)).Where(x => x.IsValid).ToList();
      else if (CreateEditExclusions != null && CreateEditExclusions.Count > 0)
        CreateEditExclusions.Clear();
      if (!string.IsNullOrWhiteSpace(metaItem.CsvExclusionList))
        CsvExclusions = metaItem.CsvExclusionList.GetTrimmedNonEmptyParts(';')
          .Select(x => new ExclusionInfo(x)).Where(x => x.IsValid).ToList();
      else if (CsvExclusions != null && CsvExclusions.Count > 0)
        CsvExclusions.Clear();
      if (!string.IsNullOrWhiteSpace(metaItem.AccessExclusionList))
        AccessExclusions = metaItem.AccessExclusionList.GetTrimmedNonEmptyParts(';');
      else if (AccessExclusions != null && AccessExclusions.Count > 0)
        AccessExclusions.Clear();
      if (!string.IsNullOrWhiteSpace(metaItem.ColoringList))
        Colorings = metaItem.ColoringList.GetTrimmedNonEmptyParts(';')
          .Select(x => new ColoringInfo(x)).Where(x => x.IsValid).ToList();
      else if (Colorings != null && Colorings.Count > 0)
        Colorings.Clear();

      //For different dropdown columns: Info1;Info2;...;InfoN
      //Thus, symbol ";" cannot be in the where clause
      if (!string.IsNullOrWhiteSpace(metaItem.CreateEditDropDownLists))
        CreateEditDropDowns = metaItem.CreateEditDropDownLists.ParseComponentsWithEnclosurePairs(';', false, DH.DefaultScriptEnclosurePairs)
          .Select(x => new DropDownInfo(x)).Where(x => x.IsValid).ToList();
      else if (CreateEditDropDowns != null && CreateEditDropDowns.Count > 0)
        CreateEditDropDowns.Clear();
      if (!string.IsNullOrWhiteSpace(metaItem.FilterDropDownLists))
        FilterDropDowns = metaItem.FilterDropDownLists.ParseComponentsWithEnclosurePairs(';', false, DH.DefaultScriptEnclosurePairs)
          .Select(x => new DropDownInfo(x)).Where(x => x.IsValid).ToList();
      else if (FilterDropDowns != null && FilterDropDowns.Count > 0)
        FilterDropDowns.Clear();
      if (!string.IsNullOrWhiteSpace(metaItem.PrefixesOfColumns))
        PrefixesOfColumns = metaItem.PrefixesOfColumns.GetTrimmedNonEmptyParts(';')
          .Select(x => new AffixColumnInfo(x)).Where(x => x.IsValid).ToList();
      else if (PrefixesOfColumns != null && PrefixesOfColumns.Count > 0)
        PrefixesOfColumns.Clear();
      if (!string.IsNullOrWhiteSpace(metaItem.PostfixesOfColumns))
        PostfixesOfColumns = metaItem.PostfixesOfColumns.GetTrimmedNonEmptyParts(';')
          .Select(x => new AffixColumnInfo(x)).Where(x => x.IsValid).ToList();
      else if (PostfixesOfColumns != null && PostfixesOfColumns.Count > 0)
        PostfixesOfColumns.Clear();
      if (!string.IsNullOrWhiteSpace(metaItem.ListColumns)) //thus allowing ; in between static value and in the enclosed sql script
        ListColumns = metaItem.ListColumns.ParseComponentsWithEnclosurePairs(';', false, DH.DefaultScriptEnclosurePairs)
          .Select(x => new ListColumnInfo(x)).Where(x => x.IsValid).ToList(); 
      else if (ListColumns != null && ListColumns.Count > 0)
        ListColumns.Clear();
      if (!string.IsNullOrWhiteSpace(metaItem.TimeStampColumns))
        TimeStampColumns = metaItem.TimeStampColumns.GetTrimmedNonEmptyParts(';')
          .Select(x => new TimeStampColumnInfo(x)).Where(x => x.IsValid).ToList();
      else if (TimeStampColumns != null && TimeStampColumns.Count > 0)
        TimeStampColumns.Clear();
      if (!string.IsNullOrWhiteSpace(metaItem.HistoryTable)) {
        HistoryInfo testHistoryTable = new HistoryInfo(metaItem.HistoryTable);
        if (testHistoryTable != null && testHistoryTable.IsValid)
          HistoryTable = testHistoryTable;
      } else
        HistoryTable = null;
      if (!string.IsNullOrWhiteSpace(metaItem.HistoryTriggers)) {
        HistoryTriggers = metaItem.HistoryTriggers.ParseComponents(';')
          .Select(x => new HistoryTriggerInfo(x)).Where(x => x.IsValid).ToList();
      } else if(HistoryTriggers != null && HistoryTriggers.Count > 0)
        HistoryTriggers.Clear();
      if (!string.IsNullOrWhiteSpace(metaItem.AutoGeneratedColumns))
        AutoGeneratedColumns = metaItem.AutoGeneratedColumns.GetTrimmedNonEmptyParts(';')
          .Select(x => new AutoGeneratedColumnInfo(x)).Where(x => x.IsValid).ToList();
      else if (AutoGeneratedColumns != null && AutoGeneratedColumns.Count > 0)
        AutoGeneratedColumns.Clear();
      if (!string.IsNullOrWhiteSpace(metaItem.ColumnSequence))
        ColumnSequence = metaItem.ColumnSequence.GetTrimmedNonEmptyParts(';');
      else if (ColumnSequence != null && ColumnSequence.Count > 0)
        ColumnSequence.Clear();
      if (!string.IsNullOrWhiteSpace(metaItem.ColumnAliases))
        ColumnAliases = metaItem.ColumnAliases.GetTrimmedNonEmptyParts(';')
          .Select(x => new CommonBaseInfo(x)).Where(x => x.IsValid && x.HasRightSide)
          .ToDictionary(x => x.Name, x => x.RightSide);
      else if (ColumnAliases != null && ColumnAliases.Count > 0)
        ColumnAliases.Clear();
      ArrangedDataColumns = GetColumnSequenceFor(RawDataColumns); //can only be applied after column sequence is defined
      if (!string.IsNullOrWhiteSpace(metaItem.EditShowOnlyColumns))
        EditShowOnlyColumns = metaItem.EditShowOnlyColumns.GetTrimmedNonEmptyParts(';');
      else if (EditShowOnlyColumns != null && EditShowOnlyColumns.Count > 0)
        EditShowOnlyColumns.Clear();
      if (!string.IsNullOrWhiteSpace(metaItem.ScriptConstructorColumns))
        ScriptConstructorColumns = metaItem.ScriptConstructorColumns.GetTrimmedNonEmptyParts(';')
          .Select(x => new ScriptConstructorColumnInfo(TableSource, x)).Where(x => x.IsValid).ToList();
      else if (ScriptConstructorColumns != null && ScriptConstructorColumns.Count > 0)
        ScriptConstructorColumns.Clear();
      if (!string.IsNullOrWhiteSpace(metaItem.ScriptColumns))
        ScriptColumns = metaItem.ScriptColumns.GetTrimmedNonEmptyParts(';')
          .Select(x => new ScriptColumnInfo(ScriptConstructorColumns, TableSource, x)).Where(x => x.IsValid).ToList();
      else if (ScriptColumns != null && ScriptColumns.Count > 0)
        ScriptColumns.Clear();
      if (!string.IsNullOrWhiteSpace(metaItem.CustomDateTimeFormatColumns))
        CustomDateTimeFormatColumns = metaItem.CustomDateTimeFormatColumns.GetTrimmedNonEmptyParts(';')
          .Select(x => new CustomDateTimeFormatInfo(x)) //only accept custom date time formats for date time columns for obvious reason
          .Where(x => x.IsValid && dateTimeColumns != null && dateTimeColumns.Any(y => y.EqualsIgnoreCase(x.Name))) 
          .ToList();
      else if (CustomDateTimeFormatColumns != null && CustomDateTimeFormatColumns.Count > 0)
        CustomDateTimeFormatColumns.Clear();
      if (!string.IsNullOrWhiteSpace(metaItem.EmailMakerTriggers))
        EmailMakerTriggers = metaItem.EmailMakerTriggers.ParseComponents(';')
          .Select(x => new EmailMakerTriggerInfo(x)).Where(x => x.IsValid).ToList();
      else if (EmailMakerTriggers != null && EmailMakerTriggers.Count > 0)
        EmailMakerTriggers.Clear();
      if (!string.IsNullOrWhiteSpace(metaItem.EmailMakers))
        EmailMakers = metaItem.EmailMakers.GetTrimmedNonEmptyParts(';')
          .Select(x => new EmailMakerInfo(x)).Where(x => x.IsValid).ToList();
      else if (EmailMakers != null && EmailMakers.Count > 0)
        EmailMakers.Clear();
      if (EmailMakerFulls != null) {
        EmailMakerFulls.Clear();
        if (EmailMakers != null && EmailMakerTriggers != null && EmailMakers.Count > 0 && EmailMakerTriggers.Count > 0)
          foreach (EmailMakerTriggerInfo trigger in EmailMakerTriggers) {
            EmailMakerInfo maker = EmailMakers.FirstOrDefault(x => x.Name.EqualsIgnoreCase(trigger.Name));
            if (maker == null)
              continue;
            EmailMakerFullInfo fullInfo = new EmailMakerFullInfo(trigger, maker);
            if (fullInfo.IsValid)
              EmailMakerFulls.Add(fullInfo);
          }
      }
      if (!string.IsNullOrWhiteSpace(metaItem.NonPictureAttachmentColumns))
        NonPictureAttachments = metaItem.NonPictureAttachmentColumns.GetTrimmedNonEmptyParts(';')
          .Select(x => new AttachmentInfo(x)).Where(x => x.IsValid).ToList();
      else if (NonPictureAttachments != null && NonPictureAttachments.Count > 0)
        NonPictureAttachments.Clear();
      if (!string.IsNullOrWhiteSpace(metaItem.DownloadColumns))
        DownloadColumns = metaItem.DownloadColumns.GetTrimmedNonEmptyParts(';');
      else if (DownloadColumns != null && DownloadColumns.Count > 0)
        DownloadColumns.Clear();
      if (!string.IsNullOrWhiteSpace(metaItem.PreActionTriggers))
        PreActionTriggers = metaItem.PreActionTriggers.ParseComponents(';')
          .Select(x => new ActionTriggerInfo(x)).Where(x => x.IsValid).ToList();
      else if (PreActionTriggers != null && PreActionTriggers.Count > 0)
        PreActionTriggers.Clear();
      if (!string.IsNullOrWhiteSpace(metaItem.PreActionProcedures))
        PreActionProcedures = metaItem.PreActionProcedures.ParseComponents(';')
          .Select(x => new ActionProcedureInfo(x)).Where(x => x.IsValid).ToList();
      else if (PreActionProcedures != null && PreActionProcedures.Count > 0)
        PreActionProcedures.Clear();
      if (PreActionProcedureFulls != null) {
        PreActionProcedureFulls.Clear();
        if (PreActionProcedures != null && PreActionTriggers != null && PreActionProcedures.Count > 0 && PreActionTriggers.Count > 0)
          foreach (ActionTriggerInfo trigger in PreActionTriggers) {
            ActionProcedureInfo procedure = PreActionProcedures.FirstOrDefault(x => x.TriggerName.EqualsIgnoreCase(trigger.TriggerName));
            if (procedure == null)
              continue;
            ActionProcedureFullInfo fullInfo = new ActionProcedureFullInfo(trigger, procedure);
            if (fullInfo.IsValid)
              PreActionProcedureFulls.Add(fullInfo);
          }
      }
      if (!string.IsNullOrWhiteSpace(metaItem.PostActionTriggers))
        PostActionTriggers = metaItem.PostActionTriggers.ParseComponents(';')
          .Select(x => new ActionTriggerInfo(x)).Where(x => x.IsValid).ToList();
      else if (PostActionTriggers != null && PostActionTriggers.Count > 0)
        PostActionTriggers.Clear();
      if (!string.IsNullOrWhiteSpace(metaItem.PostActionProcedures))
        PostActionProcedures = metaItem.PostActionProcedures.ParseComponents(';')
          .Select(x => new ActionProcedureInfo(x)).Where(x => x.IsValid).ToList();
      else if (PostActionProcedures != null && PostActionProcedures.Count > 0)
        PostActionProcedures.Clear();
      if (PostActionProcedureFulls != null) {
        PostActionProcedureFulls.Clear();
        if (PostActionProcedures != null && PostActionTriggers != null && PostActionProcedures.Count > 0 && PostActionTriggers.Count > 0)
          foreach (ActionTriggerInfo trigger in PostActionTriggers) {
            ActionProcedureInfo procedure = PostActionProcedures.FirstOrDefault(x => x.TriggerName.EqualsIgnoreCase(trigger.TriggerName));
            if (procedure == null)
              continue;
            ActionProcedureFullInfo fullInfo = new ActionProcedureFullInfo(trigger, procedure);
            if (fullInfo.IsValid)
              PostActionProcedureFulls.Add(fullInfo);
          }
      }
      TableType = !string.IsNullOrWhiteSpace(metaItem.TableType) && DH.TableTypes.Any(x => x.EqualsIgnoreCaseTrim(metaItem.TableType)) ? //not null and exists
        DH.TableTypes.First(x => x.EqualsIgnoreCaseTrim(metaItem.TableType)) : DH.NormalTableType;
      AggregationStatement = !string.IsNullOrWhiteSpace(metaItem.AggregationStatement) ?
        new AggregationStatementInfo(metaItem.AggregationStatement) : null;
      if (AggregationStatement != null && !AggregationStatement.IsValid) //not null but invalid
        AggregationStatement = null; //nullifies it
      if (!string.IsNullOrWhiteSpace(metaItem.ForeignInfoColumns))
        ForeignInfoColumns = metaItem.ForeignInfoColumns.GetTrimmedNonEmptyParts(';')
          .Select(x => new ForeignInfoColumnInfo(x)).Where(x => x.IsValid).ToList();
      else if (ForeignInfoColumns != null && ForeignInfoColumns.Count > 0)
        ForcedFilterColumns.Clear();

      IsValid = true; //Somehow, if failed before everything is finished, we cannot consider it as valid
    }

    #region extras
    #region ColumnInfo related
    public ColumnInfo CreateColumnInfo(DataColumn column, bool isColumnIncludedInIndex, bool isColumnIncludedInFilter, bool isColumnForcelyIncludedInFilter) {
      ColumnInfo info = new ColumnInfo(column);
      info.IsPictureColumn = IsPictureColumn(column.ColumnName);
      info.IsAttachmentColumn = info.IsPictureColumn || IsNonPictureAttachmentColumn(column.ColumnName);
      info.IsDownloadColumn = IsDownloadColumn(column.ColumnName);
      info.DisplayName = GetColumnDisplayName(column.ColumnName);
      info.IsPrefilledColumn = IsPrefilledColumn(column.ColumnName);
      info.IsIndexIncluded = isColumnIncludedInIndex && !info.IsPrefilledColumn && !IsNonPictureAttachmentColumn(column.ColumnName);
      info.IsIndexShowImage = info.IsPictureColumn && IsIndexShownPictureColumn(column.ColumnName);
      info.IsSciptColumn = IsScriptColumn(column.ColumnName);
      info.IsListColumn = IsListColumn(column.ColumnName);

      if (Colorings != null)
        info.Colorings = Colorings;

      //Filter. Picture columns cannot be used as filter naturally, unless it is forced to
      //But script column is always excluded from the filter
      if (!info.IsSciptColumn)
        info.IsFilterIncluded = isColumnForcelyIncludedInFilter || //forcely included columns overlook all others, except script column
          (isColumnIncludedInIndex && isColumnIncludedInFilter && !info.IsAttachmentColumn && !info.IsPrefilledColumn);

      if (info.IsDateTime && HasCustomDateTimeFormatFor(column.ColumnName, DH.IndexPageName))
        info.CustomDateTimeFormat = GetCustomDateTimeFormatFor(column.ColumnName, DH.IndexPageName);
      return info;
    }
    #endregion

    #region DateTime columns
    public bool IsDateTimeColumn(string columnName) {
      return dateTimeColumns != null && dateTimeColumns.Any(x => x.EqualsIgnoreCase(columnName));
    }
    #endregion

    #region simple selection
    public DataRow GetFullRowSource(int cid) {
      DataTable table = SQLServerHandler.GetFullDataTableWhere(DH.DataDBConnectionString, TableSource, string.Concat(DH.Cid, "=", cid));
      if (table == null || table.Rows == null || table.Rows.Count <= 0)
        return null;
      return table.Rows[0];
    }
    #endregion

    public override string ToString() {
      return TableName + " {" + TableDisplayName + "} ";
    }

    public DataColumn GetDataColumn(string columnName) {
      return RawDataColumns?.FirstOrDefault(x => x.ColumnName.Equals(columnName)); //do not use EqualsIgnoreCase here
    }
    #endregion

    #region ListColumns
    public bool IsListColumn(string columnName) {
      return ListColumns != null && ListColumns.Count > 0 &&
        ListColumns.Any(x => x.Name.EqualsIgnoreCaseTrim(columnName));
    }

    //Format: ServiceType=default|RefTableName:RefColumnName:RefOtherColumnName:ServiceStatus
    //there are two columns on the same table:
    // -> this column
    // -> changed Column name
    //The goal is to know if the changedColumn affect the column
    //if it changes to column, then the changed column must be at the last of the column
    public bool IsListColumnAffectedBy(string columnName, string changedColumnName) {
      if (string.IsNullOrWhiteSpace(columnName) || string.IsNullOrWhiteSpace(changedColumnName))
        return false;
      return ListColumns != null && ListColumns
        .Where(x => x.IsValid && x.TemplateRef != null && !string.IsNullOrWhiteSpace(x.TemplateRef.CrossTableCondColumn))
        .Any(x => x.Name.EqualsIgnoreCaseTrim(columnName) &&
          x.TemplateRef.CrossTableCondColumn.EqualsIgnoreCaseTrim(changedColumnName));
    }

    public bool IsListColumnOfType(string columnName, string type) {
      return ListColumns != null && ListColumns.Count > 0 && ListColumns.Any(
        x => x.Name.EqualsIgnoreCaseTrim(columnName) && x.ListType.EqualsIgnoreCaseTrim(type));
    }

    public string GetListColumnType(string columnName) {
      return ListColumns != null && ListColumns.Count > 0 && ListColumns.Any(
          x => x.Name.EqualsIgnoreCase(columnName)) ?
        ListColumns.FirstOrDefault(x => x.Name.EqualsIgnoreCaseTrim(columnName))?.ListType : null;
    }

    public bool ListColumnHasStaticTemplate(string columnName) {
      return ListColumns != null && ListColumns.Count > 0 && ListColumns.Any(
        x => x.TemplateRef != null && //RInfo cannot be null
        !string.IsNullOrWhiteSpace(x.TemplateRef.CondColumn) && //The condition column also cannot be null
        !string.IsNullOrWhiteSpace(x.TemplateRef.StaticCrossTableCondColumn)); //lastly, there must be static value
    }

    public string GetColumnStaticTemplate(string columnName) {
      string dataValue = string.Empty;
      ListColumnInfo info = GetListColumnInfo(columnName);
      if (info == null)
        return null;
      bool result = info.GetRefDataValue(null, null, out dataValue);
      return result ? dataValue : null;
    }

    public ListColumnInfo GetListColumnInfo(string columnName) {
      return ListColumns?.FirstOrDefault(x => x.Name.EqualsIgnoreCaseTrim(columnName));
    }

    public List<ListColumnResult> GetLiveListColumnResults(string changedColumnName, string changedColumnValue) {
      //for the given table and column, first find in the
      List<ListColumnResult> results = new List<ListColumnResult>();
      if (string.IsNullOrWhiteSpace(changedColumnValue))
        return results; //return empty result if not possible to proccess further

      var affectedColumnNames = ArrangedDataColumns
        .Where(x => IsListColumn(x.ColumnName) && IsListColumnAffectedBy(x.ColumnName, changedColumnName))
        .Select(x => x.ColumnName)
        .ToList();

      foreach (var affectedColumnName in affectedColumnNames) {
        //I need to get the info from the affected columnName
        ListColumnInfo info = GetListColumnInfo(affectedColumnName);
        if (info == null || !info.IsValid)
          continue;

        ListColumnResult result = new ListColumnResult(affectedColumnName, null); //no need to assign data value here
        if (result.UpdateLiveSubcolumnsDataValue(info, changedColumnName, changedColumnValue)) {
          result.UsedListColumnInfo = info;
          results.Add(result);
        }
      }

      return results;
    }
    #endregion ListColumns

    #region PictureColumns
    public PictureColumnInfo GetPictureColumnInfo(string columnName) {
      return PictureColumns?.FirstOrDefault(x => x.Name.EqualsIgnoreCase(columnName));
    }

    public bool IsPictureColumn(string columnName) {
      return PictureColumns != null && PictureColumns.Count > 0 &&
        PictureColumns.Any(x => x.Name.EqualsIgnoreCaseTrim(columnName));
    }

    public bool IsIndexShownPictureColumn(string columnName) {
      return IndexShownPictureColumns != null && IndexShownPictureColumns.Count > 0 &&
        IndexShownPictureColumns.Any(x => x.EqualsIgnoreCaseTrim(columnName));
    }
    #endregion PictureColumns

    #region TextFieldColumns
    //If not specified, do not apply
    public bool IsTextField(string columnName) {
      return TextFieldColumns != null &&
        TextFieldColumns.Any(x => x.Name.EqualsIgnoreCase(columnName));
    }

    public int GetTextFieldRowSize(string columnName) {
      TextFieldColumnInfo info = TextFieldColumns.FirstOrDefault(x => x.Name.EqualsIgnoreCaseTrim(columnName));
      return info == null ? TextFieldColumnInfo.DefaultRowSize : info.RowSize;
    }

    public TextFieldColumnInfo GetTextFieldInfo(string columnName) {
      return TextFieldColumns.FirstOrDefault(x => x.Name.EqualsIgnoreCaseTrim(columnName));
    }
    #endregion TextFieldColumns

    #region TimeStampColumns
    //If not specified, do not apply
    public bool IsTimeStamp(string columnName) {
      return TimeStampColumns != null && !string.IsNullOrWhiteSpace(columnName) &&
        TimeStampColumns.Any(x => x.Name.EqualsIgnoreCase(columnName));
    }

    //If not specify, applied to all
    public bool IsTimeStampAppliedFor(string columnName, string actionName) {
      bool naturallyTimeStamped = IsTimeStamp(columnName) && !string.IsNullOrWhiteSpace(actionName) &&
        TimeStampColumns.Any(x => x.Name.EqualsIgnoreCase(columnName) &&
        (x.RowActionsApplied == null || x.RowActionsApplied.Count <= 0 ||
         x.RowActionsApplied.Any(y => y.Name.EqualsIgnoreCaseTrim(actionName))));
      return naturallyTimeStamped;
    }

    public bool IsTimeStampFixedFor(string columnName, string actionName) {
      return IsTimeStamp(columnName) && !string.IsNullOrWhiteSpace(actionName) &&
        TimeStampColumns.Any(x => x.Name.EqualsIgnoreCase(columnName) &&
        (x.RowActionsApplied == null || x.RowActionsApplied.Count <= 0 ||
         x.RowActionsApplied.Any(y => y.Name.EqualsIgnoreCaseTrim(actionName) && y.IsFixed)));
    }

    public int GetTimeStampShiftFor(string columnName, string actionName) {
      TimeStampColumnInfo info = IsTimeStamp(columnName) && !string.IsNullOrWhiteSpace(actionName) ?
        TimeStampColumns.FirstOrDefault(x => x.Name.EqualsIgnoreCase(columnName)) : null;
      if (info == null)
        return 0;
      TimeStampColumnRowActionInfo actInfo = info.RowActionsApplied.FirstOrDefault(x => x.Name.EqualsIgnoreCaseTrim(actionName));
      return actInfo == null ? 0 : (int)actInfo.ShiftValue;
    }
    #endregion TimeStampColumns

    #region AutoGeneratedColumns
    //If not specify, applied to all
    public bool IsAutoGenerated(string columnName) {
      //Now, there is one more possibility for auto generated, that is, it is a group by column which is of auto-int type
      bool naturallyAutoGenerated = AutoGeneratedColumns != null && !string.IsNullOrWhiteSpace(columnName) &&
        AutoGeneratedColumns.Any(x => x.Name.EqualsIgnoreCase(columnName));
      return naturallyAutoGenerated;
    }

    //No longer valid since auto-generated is only applied for create
    ////If not specify, applied to all
    //public bool IsAutoGeneratedAppliedFor(string columnName, string actionName) {
    //  return AutoGeneratedColumns != null && !string.IsNullOrWhiteSpace(columnName) &&
    //    !string.IsNullOrWhiteSpace(actionName) &&
    //    AutoGeneratedColumns.Any(x => x.Name.EqualsIgnoreCase(columnName) &&
    //    (x.AppliedRowActions == null || !x.AppliedRowActions.Any() || //either the applied actions are not found
    //    x.AppliedRowActions.Any(y => y.EqualsIgnoreCaseTrim(actionName)))); //or the action is found among the applied row actions
    //}
    #endregion AutoGeneratedColumns

    #region Affixes
    public string GetPrefix(string columnName) {
      AffixColumnInfo info = !string.IsNullOrWhiteSpace(columnName) ?
        PrefixesOfColumns.FirstOrDefault(x => x.Name.EqualsIgnoreCase(columnName)) : null;
      return info == null ? string.Empty : info.AffixValue;
    }

    public string GetPostfix(string columnName) {
      AffixColumnInfo info = !string.IsNullOrWhiteSpace(columnName) ?
        PostfixesOfColumns.FirstOrDefault(x => x.Name.EqualsIgnoreCase(columnName)) : null;
      return info == null ? string.Empty : info.AffixValue;
    }
    #endregion Affixes

    #region DropDownColumns
    public DropDownInfo GetCreateEditDropDownColumnInfo(string columnName) {
      return getDropDownColumnInfo(CreateEditDropDowns, columnName);
    }

    public DropDownInfo GetFilterDropDownColumnInfo(string columnName) {
      return getDropDownColumnInfo(FilterDropDowns, columnName);
    }

    private DropDownInfo getDropDownColumnInfo(List<DropDownInfo> dropdowns, string columnName) {
      return dropdowns?.FirstOrDefault(x => x.Name.EqualsIgnoreCase(columnName));
    }

    public bool IsCreateEditDropDownColumn(string columnName) {
      return isDropDownColumn(CreateEditDropDowns, columnName);
    }

    public bool IsFilterDropDownColumn(string columnName) {
      return isDropDownColumn(FilterDropDowns, columnName);
    }

    private bool isDropDownColumn(List<DropDownInfo> dropdowns, string columnName) {
      return dropdowns != null && dropdowns.Count > 0 && dropdowns.Any(x => x.Name.EqualsIgnoreCase(columnName));
    }

    public bool IsCreateEditDropDownColumnAffectedBy(string columnName, string changedColumnName) {
      return isDropdownColumnAffectedBy(CreateEditDropDowns, columnName, changedColumnName);
    }

    //TODO By right, this should not be called in filter, but prepare first just in case
    public bool IsFilterDropDownColumnAffectedBy(string columnName, string changedColumnName) {
      return isDropdownColumnAffectedBy(FilterDropDowns, columnName, changedColumnName);
    }

    private bool isDropdownColumnAffectedBy(List<DropDownInfo> dropdowns, string columnName, string changedColumnName) {
      if (string.IsNullOrWhiteSpace(columnName) || string.IsNullOrWhiteSpace(changedColumnName))
        return false;
      var possibleColumns = dropdowns //possible columns
        .Where(x => x.Name.EqualsIgnoreCase(columnName) &&
          x.Items != null && x.Items.Count > 0 &&
          x.Items.Any(y => y.RefInfo != null &&
            !string.IsNullOrWhiteSpace(y.RefInfo.CrossTableCondColumn)));
      if (!possibleColumns.Any()) //if there is nothing, returns false immediately
        return false;
      if (possibleColumns.Any(x => x.Items.Any(y => y.RefInfo != null &&
          y.RefInfo.CrossTableCondColumn.EqualsIgnoreCaseTrim(changedColumnName))))
        return true;

      foreach (var col in possibleColumns)
        foreach (var rInfo in col.Items.Where(x => x.RefInfo != null).Select(x => x.RefInfo)) { //containing addtional where clauses
          if (string.IsNullOrWhiteSpace(rInfo.AdditionalWhereClause))
            continue;
          var matches = DropDownHelper.VarToValRegex.Matches(rInfo.AdditionalWhereClause);
          if (matches.Count <= 0)
            continue;
          foreach (var match in matches) {
            string checkedMatch = DropDownHelper.GetCheckedMatch(match);
            if (checkedMatch.EqualsIgnoreCase(changedColumnName))
              return true; //only if there is match such as this the column is considered affected by the change
          }
        }
      return false;
    }

    public List<LiveDropDownResult> GetLiveDropDownResults(string changedColumnName, List<LiveDropDownArg> liveDdArgs) {
      Dictionary<string, List<string>> dropdowns = new Dictionary<string, List<string>>();
      Dictionary<string, DropdownPassedArguments> passedColumnsAndValues =
        new Dictionary<string, DropdownPassedArguments>();
      foreach (var liveDdArg in liveDdArgs) {
        DropdownPassedArguments arg = new DropdownPassedArguments {
          Value = liveDdArg.SelectedValue,//liveddItems.Length > count ? liveddItems[count] : null,
          OriginalValue = liveDdArg.OriginalValue,
          DataType = liveDdArg.DataType,
        };
        passedColumnsAndValues.Add(liveDdArg.ColumnName, arg);
      }

      foreach (var liveDdArg in liveDdArgs) {
        if (liveDdArg.ColumnName == changedColumnName) //skipped
          continue;

        //check if affected
        DropDownInfo info = GetCreateEditDropDownColumnInfo(liveDdArg.ColumnName);
        if (info == null || !info.IsValid || !IsCreateEditDropDownColumnAffectedBy(liveDdArg.ColumnName, changedColumnName))
          continue; //if not affected, then leave it be...

        List<string> dropdown = createLiveCreateEditDropDownFor(liveDdArg.ColumnName, liveDdArg.OriginalValue, liveDdArg.DataType, passedColumnsAndValues);
        dropdowns.Add(liveDdArg.ColumnName, dropdown);
      }

      List<LiveDropDownResult> resultPairs = new List<LiveDropDownResult>();
      foreach (var dd in dropdowns) {
        DropdownPassedArguments arg = passedColumnsAndValues.ContainsKey(dd.Key) ?
          passedColumnsAndValues[dd.Key] : null;
        LiveDropDownResult res = new LiveDropDownResult {
          ColumnName = dd.Key,
          Values = dd.Value,
          Arg = arg,
        };
        resultPairs.Add(res);
      }
      return resultPairs;
    }

    //This is left to support direct result from javascript to call
    public List<LiveDropDownResult> GetLiveDropDownResults(string changedColumnName,
      string[] originalColumnValues, string[] liveddColumnNames, string[] liveddDataTypes, string[] liveddItems) {
      Dictionary<string, List<string>> dropdowns = new Dictionary<string, List<string>>();
      int count = 0;
      Dictionary<string, DropdownPassedArguments> passedColumnsAndValues =
        new Dictionary<string, DropdownPassedArguments>();
      foreach (var col in liveddColumnNames) {
        DropdownPassedArguments arg = new DropdownPassedArguments {
          Value = liveddItems.Length > count ? liveddItems[count] : null,
          OriginalValue = originalColumnValues[count],
          DataType = liveddDataTypes[count]
        };
        passedColumnsAndValues.Add(col, arg);
        count++;
      }
      count = 0;
      foreach (var col in liveddColumnNames) {
        if (col == changedColumnName) { //skipped
          count++;
          continue;
        }

        //check if affected
        DropDownInfo info = GetCreateEditDropDownColumnInfo(col);
        if (info == null || !info.IsValid || !IsCreateEditDropDownColumnAffectedBy(col, changedColumnName)) {
          count++;
          continue; //if not affected, then leave it be...
        }

        List<string> dropdown = 
          createLiveCreateEditDropDownFor(
            col, originalColumnValues[count], liveddDataTypes[count], 
          passedColumnsAndValues);
        dropdowns.Add(col, dropdown);
        count++;
      }

      List<LiveDropDownResult> resultPairs = new List<LiveDropDownResult>();
      foreach (var dd in dropdowns) {
        DropdownPassedArguments arg = passedColumnsAndValues.ContainsKey(dd.Key) ?
          passedColumnsAndValues[dd.Key] : null;
        //string ddStr = buildDropdownString(dd.Key, dd.Value, arg?.OriginalValue?.ToString(), arg);
        LiveDropDownResult res = new LiveDropDownResult {
          ColumnName = dd.Key,
          Values = dd.Value,
          Arg = arg,
          //ViewString = ddStr,
        };
        resultPairs.Add(res);
      }
      return resultPairs;
    }

    private List<string> createLiveCreateEditDropDownFor(string tableColumn, object originalValue,
      string dataType = DH.DropDownNumberDataType, Dictionary<string, DropdownPassedArguments> passedColumnsAndValues = null) {
      if (CreateEditDropDowns == null || !CreateEditDropDowns.Any())
        return null; //fails to enumerate, please handle without dropdown

      //This is to get "Info1" string
      DropDownInfo dropDownInfo = GetCreateEditDropDownColumnInfo(tableColumn);
      if (dropDownInfo == null || dropDownInfo.Items == null || !dropDownInfo.Items.Any())
        return null;

      //This is to process 1,2,3,[RInfo1],[RInfo2],... to distinguish between "Item" and "TableValued"
      if (dropDownInfo.Items.Any(x => !x.IsItem)) //table-valued
        return DropDownHelper.GetDropDownStringsFor(dropDownInfo, originalValue?.ToString(), dataType, filterApplied: true, passedColumnsAndValues: passedColumnsAndValues);
      return DropDownHelper.GetDropDownStringsFor(dropDownInfo, originalValue?.ToString(), dataType);
    }

    public List<string> GetStaticCreateEditDropDownFor(string tableColumn, string originalValue, string dataType = DH.DropDownNumberDataType) {
      if (CreateEditDropDowns == null || !CreateEditDropDowns.Any())
        return null; //fails to enumerate, please handle without dropdown

      DropDownInfo dropDownInfo = GetCreateEditDropDownColumnInfo(tableColumn);
      if (dropDownInfo == null || dropDownInfo.Items == null || !dropDownInfo.Items.Any())
        return null;

      return DropDownHelper.GetDropDownStringsFor(dropDownInfo, originalValue, dataType, filterApplied: false, passedColumnsAndValues: null);
    }

    public List<string> GetStaticFilterDropDownFor(string tableColumn, string dataType = DH.DropDownNumberDataType) {
      if (FilterDropDowns == null || !FilterDropDowns.Any())
        return null; //fails to enumerate, please handle without dropdown

      DropDownInfo dropDownInfo = GetFilterDropDownColumnInfo(tableColumn);
      if (dropDownInfo == null || dropDownInfo.Items == null || !dropDownInfo.Items.Any())
        return null;

      return DropDownHelper.GetDropDownStringsFor(dropDownInfo, null, dataType, filterApplied: false, passedColumnsAndValues: null);
    }
    #endregion DropDownColumns

    #region Actions and TableActions
    public bool IsDefaultAction(string actionName) {
      return DefaultActions != null && DefaultActions.Any(x => x.EqualsIgnoreCaseTrim(actionName));
    }

    public bool IsDefaultTableAction(string tableActionName) {
      return DefaultTableActions != null && DefaultTableActions.Any(x => x.EqualsIgnoreCaseTrim(tableActionName));
    }
    #endregion Actions and TableActions

    #region Regexes
    public RegexCheckedColumnInfo GetRegexCheckedColumn(string columnName) {
      return RegexCheckedColumns?.FirstOrDefault(x => x.Name.EqualsIgnoreCase(columnName));
    }

    public RegexCheckedColumnExampleInfo GetRegexCheckedColumnExample(string columnName) {
      return RegexCheckedColumnExamples?.FirstOrDefault(x => x.Name.EqualsIgnoreCase(columnName));
    }

    public bool IsRegexCheckedColumn(string columnName) {
      return RegexCheckedColumns != null && RegexCheckedColumns.Any(x => x.Name.EqualsIgnoreCase(columnName));
    }

    public bool IsRegexCheckedColumnExample(string columnName) {
      return RegexCheckedColumnExamples != null && RegexCheckedColumnExamples.Any(x => x.Name.EqualsIgnoreCase(columnName));
    }
    #endregion Regexes

    #region NumberLimits
    public NumberLimitColumnInfo GetNumberLimitColumn(string columnName) {
      return NumberLimitColumns?.FirstOrDefault(x => x.Name.EqualsIgnoreCase(columnName));
    }

    public bool IsNumberLimitColumn(string columnName) {
      return NumberLimitColumns != null && NumberLimitColumns.Any(x => x.Name.EqualsIgnoreCase(columnName));
    }
    #endregion NumberLimits

    #region ColumnSequence
    public List<DataColumn> GetColumnSequenceFor(List<DataColumn> dataColumns) {
      List<DataColumn> arrangedDataColumns = new List<DataColumn>();
      if (dataColumns != null && ColumnSequence != null && ColumnSequence.Count > 0) {
        foreach (var sequence in ColumnSequence) {
          DataColumn column = dataColumns.FirstOrDefault(x => x.ColumnName.EqualsIgnoreCase(sequence));
          if (column == null)
            continue;
          arrangedDataColumns.Add(column);
        }
        foreach (var column in dataColumns) {
          if (arrangedDataColumns.Any(x => x.ColumnName.EqualsIgnoreCase(column.ColumnName)))
            continue;
          arrangedDataColumns.Add(column);
        }
      } else
        arrangedDataColumns = dataColumns;
      return arrangedDataColumns;
    }
    #endregion

    #region ColumnAliases
    public string GetColumnDisplayName(string columnName) {
      return ColumnAliases != null && ColumnAliases.ContainsKey(columnName) ? 
        ColumnAliases[columnName].ToCamelBrokenString() : columnName.ToCamelBrokenString();
    }
    #endregion

    #region EditShowOnlyColumns
    public bool IsEditShowOnly(string columnName) {
      return EditShowOnlyColumns != null && EditShowOnlyColumns.Any(x => x.EqualsIgnoreCase(columnName));
    }
    #endregion

    #region ScriptColumns
    public bool HasScriptColumn { get { return ScriptColumns != null && ScriptColumns.Any(); } }
    public bool IsScriptColumn(string columnName) {
      return ScriptColumns != null && ScriptColumns.Any(x => x.Name.EqualsIgnoreCase(columnName));
    }

    public List<DataColumn> GetScriptDataColumns(string columnName) {
      if (!IsScriptColumn(columnName))
        return null;
      return ScriptColumns.FirstOrDefault(x => x.Name.EqualsIgnoreCase(columnName))?.DataColumns;
    }

    public ScriptColumnInfo GetScriptColumn(string columnName) {
      return ScriptColumns?.FirstOrDefault(x => x.Name.EqualsIgnoreCase(columnName));
    }
    #endregion

    #region PrefilledColumns
    public bool HasPrefilledColumn { get { return PrefilledColumns != null && PrefilledColumns.Any(); } }
    public bool IsPrefilledColumn(string columnName) {
      return PrefilledColumns != null && PrefilledColumns.Any(x => x.Name.EqualsIgnoreCase(columnName));
    }

    public PrefilledColumnInfo GetPrefilledColumn(string columnName) {
      return PrefilledColumns?.FirstOrDefault(x => x.Name.EqualsIgnoreCase(columnName));
    }
    #endregion

    #region ForcedFilterColumns
    public bool IsForcedFilterColumn(string columnName) {
      return ForcedFilterColumns != null && ForcedFilterColumns.Any(x => x.Name.EqualsIgnoreCase(columnName));
    }

    public InclusionInfo GetForcedFilterColumn(string columnName) {
      return ForcedFilterColumns?.FirstOrDefault(x => x.Name.EqualsIgnoreCase(columnName));
    }
    #endregion

    #region CustomDateTimeFormatColumns
    public bool IsCustomDateTimeFormatColumn(string columnName) {
      return CustomDateTimeFormatColumns != null && CustomDateTimeFormatColumns.Any(x => x.Name.EqualsIgnoreCase(columnName));
    }

    public bool HasCustomDateTimeFormatFor(string columnName, string pageName) {
      CustomDateTimeFormatInfo cdtfInfo = GetCustomDateTimeFormatColumn(columnName);
      if (cdtfInfo == null)
        return false;
      return cdtfInfo.IsAppliedFor(pageName);
    }

    public CustomDateTimeFormatInfo GetCustomDateTimeFormatColumn(string columnName) {
      return CustomDateTimeFormatColumns?.FirstOrDefault(x => x.Name.EqualsIgnoreCase(columnName));
    }

    public string GetCustomDateTimeFormatFor(string columnName, string pageName) {
      CustomDateTimeFormatInfo cdtfInfo = GetCustomDateTimeFormatColumn(columnName);
      if (cdtfInfo == null || !cdtfInfo.IsAppliedFor(pageName))
        return null;
      return cdtfInfo.DtFormatDictionary.FirstOrDefault(x => x.Key.EqualsIgnoreCase(pageName)).Value;
    }
    #endregion

    #region History
    private List<BaseScriptModel> createHistorySQLScripts(string rowAction, int cidInput, DataRow originalRow) {
      if (!HasValidHistoryTable)
        return null;
      List<BaseScriptModel> historyScripts = new List<BaseScriptModel>();
      foreach (var historyTrigger in HistoryTriggers) {
        DataTable table = historyTrigger.GetTriggeredDataTable(TableSource, rowAction, cidInput, originalRow);
        if (table == null || table.Rows == null || table.Rows.Count <= 0)
          continue;
        List<DataColumn> columns = new List<DataColumn>();
        List<DataRow> rows = new List<DataRow>();
        List<object> cids = new List<object>();
        foreach (DataColumn column in table.Columns) {
          if (column.ColumnName.EqualsIgnoreCase(DH.Cid))//Cid cannot be transfered
            continue;
          if (HistoryTable.IsTransferAll || //Only take the column if it is to be all transferred or if it is specifically asked to be transferred
            HistoryTable.ColumnTranslation.Keys.Any(x => x.EqualsIgnoreCase(column.ColumnName)))
            columns.Add(column);
        }
        if (columns == null || columns.Count <= 0)
          continue;
        foreach (DataRow row in table.Rows) {
          cids.Add(row[DH.Cid]);
          rows.Add(row);
        }
        for (int i = 0; i < rows.Count; ++i) {
          StringBuilder sb = new StringBuilder(string.Concat("INSERT INTO ", HistoryTable.Name, " ("));
          StringBuilder backSb = new StringBuilder(" VALUES (");
          DataRow row = rows[i];
          List<SqlParameter> pars = new List<SqlParameter>();
          object cid = cids[i];
          for (int j = 0; j < columns.Count; ++j) {
            DataColumn column = columns[j];
            object value = row[column];
            if (j > 0) {
              sb.Append(", ");
              backSb.Append(", ");
            }

            if (HistoryTable.IsTransferAll) { //if it is transfer all, just copy the column name
              sb.Append(column.ColumnName);
            } else if (HistoryTable.ColumnTranslation.Any(x => x.Key.EqualsIgnoreCase(column.ColumnName))) {
              string translatedColumnName = HistoryTable.ColumnTranslation.FirstOrDefault(x => x.Key.EqualsIgnoreCase(column.ColumnName)).Value;
              sb.Append(translatedColumnName);
            }

            string parName = string.Concat("@par", j);
            backSb.Append(parName);

            bool isAttachment = IsPictureColumn(column.ColumnName) || IsNonPictureAttachmentColumn(column.ColumnName);
            if (isAttachment) {
              string valueStr = value?.ToString();
              string attachmentPrefix = TableName + "\\"; //+ cid.ToString() + "\\"; //cannot check the cid because cid name would be different by rollback
              if (!string.IsNullOrWhiteSpace(valueStr) && !valueStr.StartsWith(attachmentPrefix))
                value = string.Concat(attachmentPrefix, valueStr);
            }

            SqlParameter par = new SqlParameter(parName, value);
            pars.Add(par);
          }
          sb.Append(", ");
          backSb.Append(", ");
          sb.Append(HistoryTable.HasCustomHRTSColumnName ? HistoryTable.CustomHRTSColumnName : DH.DefaultHRTSColumnName);
          string hrtsParName = string.Concat("@par", columns.Count);
          backSb.Append(hrtsParName);
          SqlParameter hrtsPar = new SqlParameter(hrtsParName, DateTime.Now);
          pars.Add(hrtsPar);
          sb.Append(")");
          backSb.Append(")");

          //Adding the script, delete the old one
          historyScripts.Add(new BaseScriptModel(string.Concat(sb.ToString(), backSb.ToString()), pars));
        }
        if (historyTrigger.IsDataDeleted)
          foreach (object cid in cids) {
            string deleteScript = string.Concat("DELETE FROM ", TableSource, " WHERE ", DH.Cid, "=", cid);
            historyScripts.Add(new BaseScriptModel(deleteScript));
          }
      }
      return historyScripts;
    }
    
    public List<int> HandleHistoryEvents(string rowAction, int cid, DataRow originalRow) {
      List<int> historyTriggerResults = new List<int>();
      if (HasValidHistoryTable) { //only applied when editing
        var historyScripts = createHistorySQLScripts(rowAction, cid, originalRow);
        if (historyScripts != null && historyScripts.Any())
          historyTriggerResults = SQLServerHandler.ExecuteBaseScripts(DH.DataDBConnectionString, historyScripts); //Does not need to check this for now, for simplification
      }
      return historyTriggerResults;
    }
    #endregion

    #region Action triggers related
    public List<ActionProcedureFullInfo> getTriggeredActionProcedures(string actionName, int cid, DataRow originalRow, bool postAction) {
      List<ActionProcedureFullInfo> triggeredProcedures = new List<ActionProcedureFullInfo>();
      List<ActionProcedureFullInfo> actionProcedures = postAction ? PostActionProcedureFulls : PreActionProcedureFulls;
      foreach (var procedure in actionProcedures)
        if (procedure.TryTrigger(TableSource, actionName, cid, originalRow))
          triggeredProcedures.Add(procedure);
      return triggeredProcedures;
    }

    public List<ExecuteProcedureInfo> generateExecuteProcedures(List<ActionProcedureFullInfo> triggeredActionProcedures, string actionName, Dictionary<string, object> userPars = null) {
      List<ExecuteProcedureInfo> exProcedures = new List<ExecuteProcedureInfo>();
      foreach(var actionProcedure in triggeredActionProcedures) {
        Dictionary<string, object> combinedPars = actionProcedure.GetLastDataParameters(); //data parameters
        if (userPars != null) //use parameters
          foreach (var userPar in userPars)
            combinedPars.Add("@@" + userPar.Key, userPar.Value); //combining both pars
        //Additional parameters
        DateTime now = DateTime.Now;
        DateTime today = new DateTime(now.Year, now.Month, now.Day);
        combinedPars.Add("@@" + DH.ParameterTableName, TableName);
        combinedPars.Add("@@" + DH.ParameterTableSource, TableSource);
        combinedPars.Add("@@" + DH.ParameterNow, now);
        combinedPars.Add("@@" + DH.ParameterToday, today);
        combinedPars.Add("@@" + DH.ParameterRowAction, actionName);
        ExecuteProcedureInfo exProcedure = new ExecuteProcedureInfo {
          ProcedureFull = actionProcedure,
          Parameters = combinedPars,
        };
        exProcedures.Add(exProcedure);
      }
      return exProcedures;
    }

    private List<object> handleActionProcedures(List<ActionProcedureFullInfo> procedures, string actionName, Dictionary<string, object> userPars = null) {
      if (procedures == null || procedures.Count <= 0)
        return null;
      List<ExecuteProcedureInfo> exProcedures = generateExecuteProcedures(procedures, actionName, userPars);
      List<object> results = new List<object>();
      foreach (var exProcedure in exProcedures) {
        BaseScriptModel script = exProcedure.GetExecuteProcedureSQLScript();
        if (script == null || string.IsNullOrWhiteSpace(script.Script))
          continue;
        object result = SQLServerHandler.ExecuteProcedureOrFunction(exProcedure.ProcedureFull.Procedure.IsUser ?
          DH.UserDBConnectionString : DH.DataDBConnectionString, script);
        results.Add(result);
      }
      return results;
    }

    public List<object> HandlePreActionProcedures(string actionName, int cid, DataRow originalRow, Dictionary<string, object> userPars = null) {
      List<ActionProcedureFullInfo> procedures = getTriggeredActionProcedures(actionName, cid, originalRow, postAction: false);
      return handleActionProcedures(procedures, actionName, userPars);
    }

    public List<object> HandlePostActionProcedures(string actionName, int cid, DataRow originalRow, Dictionary<string, object> userPars = null) {
      List<ActionProcedureFullInfo> procedures = getTriggeredActionProcedures(actionName, cid, originalRow, postAction: true);
      return handleActionProcedures(procedures, actionName, userPars);
    }
    #endregion

    #region Email makers related
    private List<EmailMakerFullInfo> getTriggeredEmailMakers(string actionName, int cid, DataRow originalRow) {
      List<EmailMakerFullInfo> triggeredEmailMakers = new List<EmailMakerFullInfo>();
      foreach(var emailMaker in EmailMakerFulls)
        if (emailMaker.TryTrigger(TableSource, actionName, cid, originalRow))
          triggeredEmailMakers.Add(emailMaker);
      return triggeredEmailMakers;
    }

    private List<BaseScriptModel> createEmailMakerSQLScripts(List<EmailActionInfo> emailActionInfos) {
      if (emailActionInfos == null || emailActionInfos.Count <= 0)
        return null;
      List<BaseScriptModel> scripts = new List<BaseScriptModel>();
      foreach(EmailActionInfo eaInfo in emailActionInfos) {
        BaseScriptModel script = eaInfo.GetTransferSQLScript();
        if (script == null || string.IsNullOrWhiteSpace(script.Script))
          continue;
        scripts.Add(script);
      }
      return scripts;
    }

    private List<EmailActionInfo> generateEmailActions(List<EmailMakerFullInfo> triggeredEmailMakers, string actionName, Dictionary<string, object> userPars = null) {
      List<EmailActionInfo> actions = new List<EmailActionInfo>();
      foreach (var maker in triggeredEmailMakers) {
        Dictionary<string, object> combinedPars = maker.GetLastDataParameters(TableName, TableSource);
        combinedPars.Add(DH.ParameterRowAction, actionName);
        if (userPars != null)
          foreach (var userPar in userPars)
            combinedPars.Add(userPar.Key, userPar.Value); //combining both pars
        EmailActionInfo action = new EmailActionInfo {
          EmailMaker = maker,
          Parameters = combinedPars,
          RawTransferredValues = maker.GetRawTransferredValues(combinedPars),
        };
        actions.Add(action);
      }
      return actions;
    }

    public List<int> HandleEmailEvents(string actionName, int cid, DataRow originalRow, Dictionary<string, object> userPars = null) {      
      List<EmailMakerFullInfo> triggeredEmailMakers = getTriggeredEmailMakers(actionName, cid, originalRow);
      if (triggeredEmailMakers == null || triggeredEmailMakers.Count <= 0)
        return null;
      List<EmailActionInfo> actions = generateEmailActions(triggeredEmailMakers, actionName, userPars);
      List<BaseScriptModel> scripts = createEmailMakerSQLScripts(actions);
      List<int> results = SQLServerHandler.ExecuteBaseScripts(DH.DataDBConnectionString, scripts);
      return results;
    }
    #endregion

    #region NonPictureAttachmentColumns
    public bool IsNonPictureAttachmentColumn(string columnName) {
      return NonPictureAttachments != null && NonPictureAttachments.Any(x => x.Name.EqualsIgnoreCase(columnName));
    }
    public AttachmentInfo GetNonPictureAttachmentColumn(string columnName) {
      return NonPictureAttachments?.FirstOrDefault(x => x.Name.EqualsIgnoreCase(columnName));
    }
    #endregion

    #region DownloadColumns
    public bool IsDownloadColumn(string columnName) {
      return DownloadColumns != null && DownloadColumns.Any(x => x.EqualsIgnoreCase(columnName));
    }
    #endregion

    #region Group by columns
    public bool IsGroupByColumn(string columnName) {
      return GroupByColumns != null && GroupByColumns.Any(x => x.EqualsIgnoreCase(columnName));
    }

    public GroupByColumnInfo GetGroupByColumn(string columnName) {
      return GroupByColumnInfos?.FirstOrDefault(x => x.ColumnName.EqualsIgnoreCase(columnName));
    }

    public object GetGroupByColumnValueFromString(string columnName, string value) {
      GroupByColumnInfo gbcInfo = GroupByColumnInfos?.FirstOrDefault(x => x.ColumnName.EqualsIgnoreCase(columnName));
      if (gbcInfo == null)
        throw new Exception("Not a Group By Column Info"); 
      DataColumn dataColumn = GetDataColumn(columnName);
      if (dataColumn == null)
        throw new Exception("Does not have respective data column in the database");
      if (string.IsNullOrWhiteSpace(value)) //if there is nothing, just return null
        return null;
      return value.Convert(dataColumn.DataType);
    }

    public int GetNoOfManualGroupByColumns() {
      if (GroupByColumnInfos == null)
        return 0;
      return GroupByColumnInfos.Where(x => !x.IsAutoDateTime && !x.IsAutoInt).Count();
    }

    public int GetNoOfGroupByColumns() {
      if (GroupByColumnInfos == null)
        return 0;
      return GroupByColumnInfos.Count;
    }

    public bool IsGroupByFullyAutomatic() {
      return GetNoOfManualGroupByColumns() == GetNoOfGroupByColumns();
    }

    private bool groupByEditGroupIsIdentical(List<KeyValuePair<string, object>> identifiers,
      List<KeyValuePair<string, object>> identifierResults) {
      foreach (var identifier in identifiers) {
        KeyValuePair<string, object> identifierResult = identifierResults.First(x =>
          x.Key.EqualsIgnoreCase(identifier.Key));
        if (identifier.Value == null && identifierResult.Value == null)
          continue;
        if ((identifier.Value != null && identifierResult.Value == null) ||
          (identifier.Value == null && identifierResult.Value != null))
          return false; //definitely is not identical
        if (!identifier.Value.ToString().Equals(identifierResult.Value.ToString())) //not null, can be made string
          return false; //if anything is not equal, then it is not identical
      }
      return true;
    }

    public int ApplyEditGroup(List<KeyValuePair<string, object>> identifiers,
      List<KeyValuePair<string, object>> unreplacedIdentifierResults) {
      List<KeyValuePair<string, object>> identifierResults = new List<KeyValuePair<string, object>>();
      foreach (var identifier in identifiers) {
        KeyValuePair<string, object> unreplacedIdentifierResult = unreplacedIdentifierResults
          .First(x => x.Key.EqualsIgnoreCase(identifier.Key));
        identifierResults.Add(new KeyValuePair<string, object>(unreplacedIdentifierResult.Key,
          GroupByColumnInfos.Any(x => x.ColumnName.EqualsIgnoreCase(identifier.Key) &&
          (x.IsAutoDateTime || x.IsAutoInt)) ? //group by column info is automatic, if there is any
          identifier.Value : unreplacedIdentifierResult.Value));
      }
      if (groupByEditGroupIsIdentical(identifiers, identifierResults))
        return -1; //if it is identical, does not need to process this
      Dictionary<string, object> columnAndValues = new Dictionary<string, object>();
      foreach (var identifierResult in identifierResults)
        columnAndValues.Add(identifierResult.Key, identifierResult.Value);
      List<SqlParameter> wherePars = new List<SqlParameter>();
      StringBuilder whereClause = new StringBuilder();
      int identifierIndex = 0;
      foreach (var identifier in identifiers) {
        if (identifierIndex > 0)
          whereClause.Append(" AND ");
        string whereParName = "@wherePar" + identifierIndex;
        whereClause.Append(identifier.Key);
        whereClause.Append("=");
        whereClause.Append(whereParName);
        SqlParameter wherePar = new SqlParameter(whereParName, identifier.Value ?? DBNull.Value);
        wherePars.Add(wherePar);
        ++identifierIndex;
      }
      //Currently, the result is unchecked...
      return SQLServerHandler.UpdateWhere(Aibe.DH.DataDBConnectionString, TableSource, columnAndValues, whereClause.ToString(), wherePars);
    }
    #endregion Group by columns

    #region Foreign Info Columns
    public bool IsForeignInfoColumn(string columnName) {
      return ForeignInfoColumns != null && ForeignInfoColumns.Any(x => x.Name.EqualsIgnoreCase(columnName));
    }

    public ForeignInfoColumnInfo GetForeignInfoColumn(string columnName) {
      return ForeignInfoColumns?.FirstOrDefault(x => x.Name.EqualsIgnoreCase(columnName));
    }
    #endregion Foreign Info Columns
  }
}