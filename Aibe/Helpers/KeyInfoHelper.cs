using Aibe.Models;
using System;
using System.Collections.Generic;
using System.Data;
using System.Linq;
using Extension.Database.SqlServer;
using Extension.String;

namespace Aibe.Helpers {
  public class KeyInfoHelper {
    //TODO datetime data parsing could be problematic if not standardized
    public static object ExtractValueAsObjectForWebApi(string dataType, string dataValue, DateTime refDtNow,
      string tableSource = null, string pureKeyName = null, bool isTimeStamp = false, bool isTimeStampFixed = false,
      int timeStampShift = 0, bool isAutoGenerated = false, List<KeyValuePair<string, string>> tableColumnNamePairs = null) { //given string of data type and value, change it to the appropriate object!
      if (string.IsNullOrWhiteSpace(dataType) || string.IsNullOrWhiteSpace(dataValue) || dataValue.ToUpper().Trim() == DH.NULL) //null immediately returned
        return null;

      if (isTimeStamp) {
        DateTime timeStamp = refDtNow.AddSeconds(timeStampShift);
        if (string.IsNullOrWhiteSpace(dataValue) || !isTimeStampFixed) //if the value is empty or is not fixed
          return timeStamp; //immediately returns the object
        //if the value is not empty or it is fixed, then follow the procedure        
      }

      if (isAutoGenerated) { //gives next value for auto-generation number
        if (tableColumnNamePairs == null) { //single valued
          decimal decVal = SQLServerHandler.GetAggregatedValue(DH.DataDBConnectionString, tableSource, pureKeyName, DH.AggrMax);
          return decVal + 1;
        } else {
          tableColumnNamePairs.Insert(0, new KeyValuePair<string, string>(tableSource, pureKeyName));
          decimal decVal = SQLServerHandler.GetAggregatedValues(DH.DataDBConnectionString, tableColumnNamePairs, DH.AggrMin);
          return decVal + 1;
        }
      }

      try {
        bool parseResult;
        string valueRaw = dataValue;
        switch (dataType) {
          case DH.StringDataType:
            if (!valueRaw.StartsWith("'") || !valueRaw.EndsWith("'") || valueRaw.Length < 3)
              return null;
            return valueRaw.Substring(1, valueRaw.Length - 2);
          case DH.Int16DataType:
            short valInt16;
            parseResult = short.TryParse(valueRaw, out valInt16);
            if (parseResult)
              return valInt16;
            else return null;
          case DH.Int32DataType:
            int valInt32;
            parseResult = int.TryParse(valueRaw, out valInt32);
            if (parseResult)
              return valInt32;
            else return null;
          case DH.Int64DataType:
            long valInt64;
            parseResult = long.TryParse(valueRaw, out valInt64);
            if (parseResult)
              return valInt64;
            else return null;
          case DH.DateTimeDataType:
            DateTime valDt; //this is going to be quite tricky
            if (!valueRaw.StartsWith("'") || !valueRaw.EndsWith("'") || valueRaw.Length < 3)
              return null;
            string dtStr = valueRaw.Substring(1, valueRaw.Length - 2);
            parseResult = DateTime.TryParse(dtStr, out valDt);
            if (parseResult)
              return valDt;
            else return null;
          case DH.UInt16DataType:
            ushort valUInt16;
            parseResult = ushort.TryParse(valueRaw, out valUInt16);
            if (parseResult)
              return valUInt16;
            else return null;
          case DH.UInt32DataType:
            uint valUInt32;
            parseResult = uint.TryParse(valueRaw, out valUInt32);
            if (parseResult)
              return valUInt32;
            else return null;
          case DH.UInt64DataType:
            ulong valUInt64;
            parseResult = ulong.TryParse(valueRaw, out valUInt64);
            if (parseResult)
              return valUInt64;
            else return null;
          case DH.ByteDataType:
            byte valByte;
            parseResult = byte.TryParse(valueRaw, out valByte);
            if (parseResult)
              return valByte;
            else return null;
          case DH.SByteDataType:
            sbyte valSByte;
            parseResult = sbyte.TryParse(valueRaw, out valSByte);
            if (parseResult)
              return valSByte;
            else return null;
          case DH.DecimalDataType:
            decimal valDec;
            parseResult = decimal.TryParse(valueRaw, out valDec);
            if (parseResult)
              return valDec;
            else return null;
          case DH.DoubleDataType:
            double valDouble;
            parseResult = double.TryParse(valueRaw, out valDouble);
            if (parseResult)
              return valDouble;
            else return null;
          case DH.SingleDataType:
            float valFloat;
            parseResult = float.TryParse(valueRaw, out valFloat);
            if (parseResult)
              return valFloat;
            else return null;
          case DH.BooleanDataType:
            bool valBool;
            if (valueRaw.Trim() == "0")
              valBool = false;
            else if (valueRaw.Trim() == "1")
              valBool = true;
            else return null;
            return valBool;
          case DH.CharDataType:
            char valChar;
            if (!valueRaw.StartsWith("'") || !valueRaw.EndsWith("'") || valueRaw.Length < 3)
              return null;
            valueRaw = valueRaw.Substring(1, valueRaw.Length - 2);
            parseResult = char.TryParse(valueRaw, out valChar);
            if (parseResult)
              return valChar;
            else return null;
          default:
            return null;
        }
      } catch {
        return null;
      }
    }

    private static List<string> getUsedKeys(Dictionary<string, string> collections, IEnumerable<string> filteredKeys) {
      var usedKeys = new List<string>();

      //Columns must be known! check against the table's columns!
      foreach (var key in filteredKeys) { //only collect the filter number, do nothing at this moment          
        if (!collections.ContainsKey(key))
          continue;
        var value = collections[key];
        if (string.IsNullOrWhiteSpace(value))
          continue;
        usedKeys.Add(key);
      }

      return usedKeys;
    }

    public static CompleteKeyInfo GetCompleteKeyInfo(string tableSource, Dictionary<string, string> collections,
      IEnumerable<string> filteredKeys, List<DataColumn> columns,
      bool filterStyle = false, MetaInfo meta = null, string actionType = null) {
      var usedKeys = getUsedKeys(collections, filteredKeys);
      List<string> columnNames = columns.Select(x => x.ColumnName).ToList();
      var keyInfos = usedKeys.Select(x => new KeyInfo(tableSource, x)).Where(x => columnNames.Any(y => y.EqualsIgnoreCase(x.PureKeyName))).ToList();
      var nullifiedKeyInfos = columnNames.Except(usedKeys).Select(x => new KeyInfo(tableSource, x) { IsNullified = true }).ToList();
      if (!filterStyle) {
        keyInfos = keyInfos.Where(x => !x.AddKeyName.EqualsIgnoreCase(DH.CreateEditTimeAppendixName) &&
          !x.AddKeyName.EqualsIgnoreCase(DH.CreateEditPictureLinkAppendixName) &&
          !x.AddKeyName.EqualsIgnoreCase(DH.CreateEditNonPictureAttachmentAppendixName)).ToList();
        foreach (var keyInfo in keyInfos) {
          DataColumn column = columns.FirstOrDefault(x => x.ColumnName.EqualsIgnoreCase(keyInfo.PureKeyName));
          keyInfo.DataType = column.DataType.ToString().Substring(DH.SharedPrefixDataType.Length);
          keyInfo.UpdateTimeStampAndAutoGenerated(meta, column.ColumnName, actionType);
        }
        foreach (var nullifiedKeyInfo in nullifiedKeyInfos) {
          DataColumn column = columns.FirstOrDefault(x => x.ColumnName.EqualsIgnoreCase(nullifiedKeyInfo.PureKeyName));
          nullifiedKeyInfo.DataType = column.DataType.ToString().Substring(DH.SharedPrefixDataType.Length);
          nullifiedKeyInfo.UpdateTimeStampAndAutoGenerated(meta, column.ColumnName, actionType);
        }
      }
      CompleteKeyInfo completeKeyInfo = new CompleteKeyInfo { ValidKeys = keyInfos, NullifiedKeys = nullifiedKeyInfos };
      return completeKeyInfo;
    }

    public static CompleteKeyInfo GetCompleteKeyInfo(string tableSource, Dictionary<string, string> collections,
      IEnumerable<string> filteredKeys,
      bool filterStyle = false) {
      return GetCompleteKeyInfo(tableSource, collections, filteredKeys, SQLServerHandler.GetColumns(DH.DataDBConnectionString, tableSource), filterStyle);
    }
  }
}